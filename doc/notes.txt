////////////////////////////////////////////////////////////////////////////////
///
/// Vector implementation inspired by "Exception-Safety Issues and Techniques"
/// chapter of Herb Sutter's book and by gcc/stl_vector.h.
///
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///
/// Here is an examples of desired code.
///
/// template <typename Type, typename Allocator>
/// VectorBase<Type, Allocator>::VectorBase(VectorBase&& other) noexcept
///     : VectorImpl{other.capacity_} {
///   impl_.Append(std::move(other.impl));
/// }
///
/// template <typename Type, typename Allocator>
/// void Vector<Type, Allocator>::Reserve(SizeType capacity) {
///   VectorImpl impl{capacity};
///   impl->Append(std::move(this->impl_));
///   this->impl_.Swap(impl_);
/// }
///
/// template <typename Type, typename Allocator>
/// template <typename... ArgTypes>
/// void Vector<Type, Allocator>::PushBack(ArgTypes&&... args) {
///   if (IsFull()) {
///     Reserve();
///   }
///   ConstructAtEnd(std::forward<ArgTypes>(args)...);
/// }
///
/// template <typename Type, typename Allocator>
/// void VectorImpl<Type, Allocator>::Append(VectorImpl&& other) noexcept {
///   assert(size_ + other.size_ < other.capacity_);
///
///   for () {
///
///   }
/// }
///
/// where allocations are happens
///
/// all memory management happens in vector base
///
/// vector
///
/// list
///
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///
/// Container methods order
///   > container constructors
///   > accessors such as operator[], at(), front(), back(), etc
///   > iterators such as begin(), end(), cbegin(), cend(), rbegin(), rend(),
///   > capacity accessors and mutators such as empty(), size(), capacity(),
///     reserve(), shrink_to_fit()
///   > mutators such as clear(), insert(), emplace(), push_back(),
///   emplace_back(),
///     pop_back(), etc
///
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///
/// Arbitrary constructor can throw an exception
/// Move constructor always noexcept
///
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///
/// Errors can be divided into two categories.
///
/// First one is errors that can not be handled. For example, malloc returns
/// NULL or new(std::nothrow) returns nullptr. You have no way to recover
/// program execution and common reason for these errors is programmer error.
/// Thus, you should explicitly report about these errors, for example using
/// assertions.
///
/// Second one is errors that can be handled. For these errors we can use both
/// exception or errors that can't be ignored.
///
/// Let consider exceptions that can be thrown by standard library containers.
///
/// std::bad_alloc is exception after which code execution can not be
/// recovered because reasons why allocator doesn't work usually are bugs
/// in program.
///
/// std::out_of_range is exception which also points to program bugs.
///
/// Instead of throwing these exceptions we use assertions that check
/// conditions required for correct code execution.
///
////////////////////////////////////////////////////////////////////////////////

/// Rule of zero
///
/// Idiom that direct us is
/// "RAII - Resource Acquisition Is Initialization"
///
/// Also we have a Rule of Zero and Rule of Five.
///
/// But, Rule of Zero conflicts with RAII because if we have only copy/move
/// constructors, copy/move assignment operators and destructor where does
/// resource acquisition happens.
///
/// VectorBase is memory manager. VectorBase add value semantic for raw memory
/// buffer.
///
/// ConstructAtEnd, DestroyAtEnd, DestroyAll, etc

/// Perfect hierarchy obtained!

template <typename Type>
class Buffer {};

template <typename Type, typename Allocator>
class VectorBase : protected Allocator,
                   protected Buffer<Type> {};

template <typename Type, typename Allocator>
class Vector : protected VectorBase<Type, Allocator> {};


template <typename CharType, typename CharTraits, typename Allocator>
class StringBase : protected Allocator,
                   protected Buffer<CharType> {};

template <typename CharType, typename CharTraits, typename Allocator>
class String : protected StringBase<CharType, CharTraits, Allocator> {};

template <typename Type>
class ArrayBase : protected Buffer<Type> {};

template <typename Type>
class Array : protected ArrayBase<Type> {};

# include order #

libraries in alphabet order
files inside library also in alphabet order
detail is last includes



// container behaviour
//
// default constructor
//   > initialize allocator by get_default_memory_resource
//
// copy constructor
//   > initialize allocator by pointer to memory resource given by other allocator
//   > copy
//
// copy assignment
//   > copy and swap
//
// move constructor
//   > initialize allocator by pointer to memory resource given by other allocator and transorm other allocator to invalid state
//   > move
//
// move assignment
//   > if allocators are equal (i.e. allocators point to the same memory resource)
//     > move and swap
//   > else
//     > copy and swap
